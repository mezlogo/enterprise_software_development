#include <stdio.h>
#include <stdlib.h>
#include "ArrayHandler.h"

/*Представляем основной модуль реализующий управление памяти*/

////////
//Поля//
////////
//Количество подкуч. Каждая подкуча содержит переменные определенного размера

//Собственно количество байт для хранения
#define TOTAL_HEAP_SIZE 100000
#define MAX_HEAPS_COUNT 10
#define MAX_VARIABLES 100
//Память-куча для хранения данных
char heap[TOTAL_HEAP_SIZE];
//Переменные
char heapsCount;
char total_variables[MAX_VARIABLES] = {0};
int heapsVariablesCount[MAX_HEAPS_COUNT];
int heapsVariableSize[MAX_HEAPS_COUNT];

long heapsSize[MAX_HEAPS_COUNT];
char* heapsAddress[MAX_HEAPS_COUNT];
int countVarribleInsidHeap[MAX_HEAPS_COUNT];
int offsetVarribles[MAX_HEAPS_COUNT];

/***@
 * Функция: "Выделения памяти"
 * Сигнатура: 
 * - Вход: целочисленная переменная = размер выделяемого блока
 * - Выход: указатель на область памяти, либо null
 * Алгоритм: 
 * 0) Валидация: Размер ячейки для выделения - положительное число, не больше размера последней подкучи(!!!).
 * 1) Определить для какой подкучи подходит размер выделяемый переменной
 * - Во время обхода массива с размерами подкучь (!!!)
 * - Получаем тот индекс подкучи, размер которого не меньше требуемого
 * 2) Ищем первую свободную переменную, занимаем ее
 * - Получаем переменные для данной подкучи, и количество этих переменных
 * - Ободим этот массив, если нашли 0, занимаем его, вписав 1, иначе инкриментим подкучу и повторяем
 * - При достижении конца кучи, если не найдена пустая переменная, возвращаем 0
 * 3) Вычисляем на основании смещения занятой переменной, относительно начала всех переменных подкучи,
 * высчитываем смещение в байтах, относительно начала подкучи, в общей кучи
 * 4) Возвращаем полученное значение
@***/
char* allocate(int size){
    return heap;
}

/***@
 * Функция: "Освобождение памяти"
 * Сигнатура: 
 * - Вход: указатель на область в куче
 * - Выход: целочисленное число, отрицательное, если ошибка.
 * Алгоритм:
 * 0) Валидация: Указатель между началом и конца кучи(!!!).
 * 1) Определить на какую подкучу ссылается переменная
 * - Во время обхода массива с адресами (!!!) начала подкучь, расположенными в куче
 * - Получаем тот индекс подкучи, адрес начала которой неменьше на которую указывает переменная, 
 * но и следующая подкуча имеет адрес ПОСЛЕ переменной
 * 2) Вычисляем смещение в байтах, между указателем переменной и адресом начала подкучи
 * 3) Вычисляем индекс переменной, в занимаемой подкучи
 * 4) Устанавливаем массив переменных 0, для данной подкучи с данным смещением
@***/
int removeVar(void* var){
    return 1;
}

/***@
 * Функция: (грязный интерфейс) "Переинициализация подкучь и их переменных"
 * Сигнатура: 
 * - Вход: целочисленная переменная = количество подкучь,
 *          массив размеров подкучь,
 *          массив количества переменных в подкучах
 * - Выход: целочисленный код завершения, отрицателен, если ошибка
 * Алгоритм:
 * 0) Валидация: требуемый блок памяти (сумма размера подкучи на ее количество переменных), 
 * не больше статического размера кучи
 * - Размеры подкучь по увеличению
 * 1) Обнуление переменных
 * 2) Приравнивание переменных
 * 3) Вычисление кэшируемых данных:
 * - Максимальный размер подкучи (последний подкучи)
 * - Конец кучи (указатель на последний байт, в куче)
 * - Массив указателей на начало каждой подкучи, внутри кучи
 * - Массив указателей на начало переменных для каждой подкучи, внутри массива переменных
@***/
int initHeap(char _heapsCount, int* _heapsVariableSize, int* _heapsVariablesCount){
    if (MAX_HEAPS_COUNT < _heapsCount || TOTAL_HEAP_SIZE < sumOfHeapByVarCountAndSize(_heapsVariableSize, _heapsVariablesCount, _heapsCount) || 0 <= isAscendingOrder(_heapsVariableSize, _heapsCount)) return -1;
    
    resetAllChars(total_variables, MAX_VARIABLES);
    
    
    
    return 1;
}
