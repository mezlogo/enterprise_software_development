#include <stdio.h>
#include <stdlib.h>
#include "ArrayHandler.h"

/*Представляем основной модуль реализующий управление памяти*/


////////
//Поля//
////////
//Количество подкуч. Каждая подкуча содержит переменные определенного размера
#define HEAPS_COUNT 5
//Собственно количество байт для хранения
#define HEAP_SIZE 100000

//Память-куча для хранения данных
char heap[HEAP_SIZE];
//Переменные
char varribles[100] = {0};

long heapsSize[HEAPS_COUNT];
long heapsAddress[HEAPS_COUNT];
int countVarribleInsidHeap[HEAPS_COUNT];
int offsetVarribles[HEAPS_COUNT];

/***@
 * Функция: "Выделения памяти"
 * Сигнатура: 
 * - Вход: целочисленная переменная = размер выделяемого блока
 * - Выход: указатель на область памяти, либо null
 * Алгоритм: 
 * 0) Валидация: Размер ячейки для выделения - положительное число, не больше размера последней подкучи(!!!).
 * 1) Определить для какой подкучи подходит размер выделяемый переменной
 * - Во время обхода массива с размерами подкучь (!!!)
 * - Получаем тот индекс подкучи, размер которого неменьше требуемого
 * 2) Ищем первый свободный участок памяти, переменную
 * - Получаем переменные для данной подкучи, и количество этих переменных
 * - Ободим этот массив, если нашли 0, занимаем его, вписав 1, иначе инкриментим подкучу и повторяем
 * 3) При достижении конца кучи, если не найдена пустая переменная, возвращаем 0
 * - Иначе, на основании смещения занятой переменной, относительно начала всех переменных подкучи,
 * высчитываем смещение в байтах, относительно начала подкучи, в общей кучи
 * 4) Возвращаем полученное значение
@***/
char* allocate(int size){
    return getPointer(heap, HEAPS_COUNT, heapsSize, heapsAddress, offsetVarribles, countVarribleInsidHeap, varribles, size);
}

/***@
 * Функция: "Освобождение памяти"
 * Сигнатура: 
 * - Вход: указатель на область в куче
 * - Выход: целочисленное число, отрицательное, если ошибка.
 * Алгоритм:
 * 0) Валидация: Указатель между началом и конца кучи(!!!).
 * 1) Определить на какую подкучу ссылается переменная
 * - Во время обхода массива с адресами (!!!) начала подкучь, расположенными в куче
 * - Получаем тот индекс подкучи, адрес начала которой неменьше на которую указывает переменная, 
 * но и следующая подкуча имеет адрес ПОСЛЕ переменной
 * 2) Вычисляем смещение в байтах, между указателем переменной и адресом начала подкучи
 * 3) Вычисляем индекс переменной, в занимаемой подкучи
 * 4) Устанавливаем массив переменных 0, для данной подкучи с данным смещением
@***/
int removeVar(void* var){
    return removePointer(var, HEAPS_COUNT, heapsSize, (void**) heapsAddress, offsetVarribles, varribles, HEAP_SIZE);
}

/***@
 * Функция: (грязный интерфейс) "Переинициализация подкучь и их переменных"
 * Сигнатура: 
 * - Вход: целочисленная переменная = количество подкучь,
 *          массив размеров подкучь,
 *          массив количества переменных в подкучах
 * - Выход: целочисленный код завершения, отрицателен, если ошибка
 * Алгоритм:
 * 0) Валидация: требуемый блок памяти (сумма размера подкучи на ее количество переменных), 
 * не больше статического размера кучи
 * - Размеры подкучь по увеличению
 * 1) Обнуление переменных
 * 2) Приравнивание переменных
 * 3) Вычисление кэшируемых данных:
 * - Максимальный размер подкучи (последний подкучи)
 * - Конец кучи (указатель на последний байт, в куче)
 * - Массив указателей на начало каждой подкучи, внутри кучи
 * - Массив указателей на начало переменных для каждой подкучи, внутри массива переменных
@***/

int main(int argc, char **argv) {return 0;}